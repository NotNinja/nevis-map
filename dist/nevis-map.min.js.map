{"version":3,"file":"nevis-map.min.js","sources":["../src/entry.js","../src/nevis-map.js"],"sourcesContent":["/*\n * Copyright (C) 2017 Alasdair Mercer, Skelp\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict'\n\nvar Nevis = require('nevis')\n\n// TODO: Complete\n\n/**\n * TODO: Document\n *\n * @param {number} hash -\n * @param {*} key -\n * @param {*} value -\n * @param {?Entry} next -\n * @param {NevisMap~Options} options -\n * @public\n * @constructor\n * @extends Nevis\n */\nvar Entry = Nevis.extend('Entry', function(hash, key, value, next, options) {\n  /**\n   * TODO: Document\n   *\n   * @protected\n   * @type {number}\n   * @memberof Entry#\n   */\n  this.hash = hash\n\n  /**\n   * TODO: Document\n   *\n   * @public\n   * @type {*}\n   * @memberof Entry#\n   */\n  this.key = key\n\n  /**\n   * TODO: Document\n   *\n   * @public\n   * @type {*}\n   * @memberof Entry#\n   */\n  this.value = value\n\n  /**\n   * TODO: Document\n   *\n   * @protected\n   * @type {?Entry}\n   * @memberof Entry#\n   */\n  this.next = next\n\n  /**\n   * TODO: Document\n   *\n   * @private\n   * @type {NevisMap~Options}\n   * @memberof Entry#\n   */\n  this._options = options\n}, {\n\n  /**\n   * @inheritdoc\n   * @override\n   * @memberof Entry#\n   */\n  equals: function(obj) {\n    if (obj == null || !(obj instanceof Entry)) {\n      return false\n    }\n\n    var options = this._options.equals\n\n    return new Nevis.EqualsBuilder()\n      .append(this.key, obj.key, options)\n      .append(this.value, obj.value, options)\n      .build()\n  },\n\n  /**\n   * @inheritdoc\n   * @override\n   * @memberof Entry#\n   */\n  hashCode: function() {\n    var options = this._options.hashCode\n\n    return Nevis.hashCode(this.key, options) ^ Nevis.hashCode(this.value, options)\n  },\n\n  /**\n   * @inheritdoc\n   * @override\n   * @memberof Entry#\n   */\n  toString: function() {\n    return this.key + '=' + this.value\n  }\n\n})\n\nmodule.exports = Entry\n","/*\n * Copyright (C) 2017 Alasdair Mercer, Skelp\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict'\n\nvar Nevis = require('nevis')\n\nvar Entry = require('./entry')\n\n/**\n * TODO: Document\n *\n * @param {Array.<Array>} [entries] -\n * @param {NevisMap~Options} [options] -\n * @public\n * @constructor\n * @extends Nevis\n */\nvar NevisMap = Nevis.extend('NevisMap', function(entries, options) {\n  // TODO: Complete\n\n  /**\n   * The options being used by this {@link NevisMap}.\n   *\n   * @private\n   * @type {NevisMap~Options}\n   * @memberof NevisMap#\n   */\n  this._options = options || {}\n}, {\n\n  /**\n   * Removes all mappings from this {@link NevisMap}.\n   *\n   * @return {void}\n   * @public\n   * @memberof NevisMap#\n   */\n  clear: function() {\n    // TODO: Complete\n  },\n\n  /**\n   * Removes the mapping for the specified <code>key</code> from this {@link NevisMap}, if present.\n   *\n   * This method will return <code>true</code> if a mapping for <code>key</code> existed and has been removed, otherwise\n   * it will return <code>false</code>.\n   *\n   * @param {*} key - the key whose mapping is to be removed\n   * @return {boolean} <code>true</code> if a mapping for <code>key</code> existed and has been removed; otherwise\n   * <code>false</code>.\n   * @public\n   * @memberof NevisMap#\n   */\n  delete: function(key) {\n    // TODO: Complete\n    return false\n  },\n\n  /**\n   * Returns the mappings within this {@link NevisMap}.\n   *\n   * The mappings are returned in a multi-dimensional array where the array contains the <code>[key, value]</code> pairs\n   * for each mapping.\n   *\n   * @return {Array.<Array>} A multi-dimensional array containing the key/value pairs for each mapping.\n   * @public\n   * @memberof NevisMap#\n   */\n  entries: function() {\n    // TODO: Complete\n    return []\n  },\n\n  /**\n   * Returns the mappings within this {@link NevisMap}.\n   *\n   * @return {Entry[]} The mappings.\n   * @public\n   * @memberof NevisMap#\n   */\n  entrySet: function() {\n    // TODO: Complete\n    return []\n  },\n\n  /**\n   * Iterates over the mappings within this {@link NevisMap}, invoking the specified <code>callback</code> function once\n   * per key/value pair.\n   *\n   * @param {NevisMap~ForEachCallback} callback - the function to be called for each key/value pair\n   * @param {Object} [context] - the context (value for <code>this</code>) to be used when invoking\n   * <code>callback</code>\n   * @return {void}\n   * @public\n   * @memberof NevisMap#\n   */\n  forEach: function(callback, context) {\n    // TODO: Optimize, if needed\n    this.entries().forEach(function(entry) {\n      callback.call(context, entry[1], entry[0], this)\n    }, this)\n  },\n\n  /**\n   * Returns the value to which the specified <code>key</code> is mapped in this {@link NevisMap}, where possible.\n   *\n   * A return value of <code>undefined</code> does not necessarily indicate that this {@link NevisMap} contains no\n   * mapping for <code>key</code> as it's also possible that this {@link NevisMap} explicitly maps <code>key</code> to\n   * <code>undefined</code>. The {@link NevisMap#has} operation may be used to distinguish these two cases.\n   *\n   * @param {*} key - the key whose associated value is to be returned\n   * @return {*} The value to which <code>key</code> is mapped, or <code>undefined</code> if no mapping exists for\n   * <code>key</code>.\n   * @public\n   * @memberof NevisMap#\n   */\n  get: function(key) {\n    // TODO: Complete\n    return null\n  },\n\n  /**\n   * This is a convenient shorthand for the {@link NevisMap#hasKey} method that fits well with ES2015's\n   * <code>Map</code> API.\n   *\n   * @param {*} key - the key whose presence is to be checked\n   * @return {boolean} <code>true</code> if this {@link NevisMap} contains a mapping for <code>key</code>; otherwise\n   * <code>false</code>.\n   * @public\n   * @memberof NevisMap#\n   */\n  has: function(key) {\n    return this.hasKey(key)\n  },\n\n  /**\n   * Returns whether this {@link NevisMap} contains a mapping for the specified <code>key</code>.\n   *\n   * @param {*} key - the key whose presence is to be checked\n   * @return {boolean} <code>true</code> if this {@link NevisMap} contains a mapping for <code>key</code>; otherwise\n   * <code>false</code>.\n   * @public\n   * @memberof NevisMap#\n   */\n  hasKey: function(key) {\n    // TODO: Complete\n    return false\n  },\n\n  /**\n   * Returns whether this {@link NevisMap} contains a mapping for the specified <code>value</code>.\n   *\n   * @param {*} value - the value whose presence is to be checked\n   * @return {boolean} <code>true</code> if this {@link NevisMap} contains a mapping for <code>value</code>; otherwise\n   * <code>false</code>.\n   * @public\n   * @memberof NevisMap#\n   */\n  hasValue: function(value) {\n    // TODO: Complete\n    return false\n  },\n\n  /**\n   * Returns the keys contained within this {@link NevisMap}.\n   *\n   * @return {Array} The mapped keys.\n   * @public\n   * @memberof NevisMap#\n   */\n  keys: function() {\n    // TODO: Complete\n    return []\n  },\n\n  /**\n   * Removes the mapping for the specified <code>key</code> from this {@link NevisMap}, if present.\n   *\n   * This method returns the value with which <code>key</code> was previously associated, or <code>undefined</code> no\n   * mapping existed for <code>key</code>.\n   *\n   * A return value of <code>undefined</code> does not necessarily indicate that no mapping existed for\n   * <code>key</code> as it's also possible that key was explicitly mapped to <code>undefined</code>. If this certainty\n   * is needed, use in conjunction with {@link NevisMap#hasKey} or use {@link NevisMap#delete} instead.\n   *\n   * @param {*} key - the key whose mapping is to be removed\n   * @return {*} The previous value associated with <code>key</code> or <code>undefined</code> if there was no mapping.\n   * @public\n   * @memberof NevisMap#\n   */\n  remove: function(key) {\n    // TODO: Complete\n    return null\n  },\n\n  /**\n   * Associates the specified <code>value</code> with the <code>key</code> provided in this {@link NevisMap}.\n   *\n   * If <code>key</code> was previously associated with a value, the old value is replaced with <code>value</code>.\n   *\n   * @param {*} key - the key with which <code>value</code> is to be associated\n   * @param {*} value - the value to be associated with <code>key</code>\n   * @return {NevisMap} A reference to this {@link NevisMap} for chaining purposes.\n   * @public\n   * @memberof NevisMap#\n   */\n  set: function(key, value) {\n    // TODO: Complete\n    return this\n  },\n\n  /**\n   * Associates all of the key/value pairs within the specified <code>entries</code> in this {@link NevisMap}.\n   *\n   * If any key was previously associated with a value, the old value is replaced with the new value.\n   *\n   * <code>entries</code> can either be a multi-dimensional array where the array contains the <code>[key, value]</code>\n   * pairs for each mapping or an instance of {@link NevisMap}.\n   *\n   * @param {Array.<Array>|NevisMap} [entries] - the key/value pairs (or {@link NevisMap} containing them) to be\n   * associated\n   * @return {NevisMap} A reference to this {@link NevisMap} for chaining purposes.\n   * @public\n   * @memberof NevisMap#\n   */\n  setAll: function(entries) {\n    // TODO: Complete\n    return this\n  },\n\n  /**\n   * Returns the number of mappings within this {@link NevisMap}.\n   *\n   * @return {number} The size.\n   * @public\n   * @memberof NevisMap#\n   */\n  size: function() {\n    // TODO: Complete\n    return 0\n  },\n\n  /**\n   * Returns an ES2015 <code>Map</code> containing the mappings within this {@link NevisMap}.\n   *\n   * @return {Map} A <code>Map</code> containing all key/value pairs.\n   * @public\n   * @memberof NevisMap#\n   */\n  toMap: function() {\n    // TODO: Optimize, if needed (would passing this work? if so, is that any better?)\n    return new Map(this.entries())\n  },\n\n  /**\n   * Returns the values contained within this {@link NevisMap}.\n   *\n   * @return {Array} The mapped values.\n   * @public\n   * @memberof NevisMap#\n   */\n  values: function() {\n    // TODO: Complete\n    return []\n  },\n\n  /**\n   * @inheritdoc\n   * @override\n   * @memberof NevisMap#\n   */\n  equals: function(obj) {\n    // TODO: Complete\n    return false\n  },\n\n  /**\n   * @inheritdoc\n   * @override\n   * @memberof NevisMap#\n   */\n  hashCode: function() {\n    // TODO: Complete\n    return 0\n  },\n\n  /**\n   * @inheritdoc\n   * @override\n   * @memberof NevisMap#\n   */\n  toString: function() {\n    // TODO: Complete\n    return ''\n  },\n\n  /**\n   * Creates an {@link Entry} based on the information provided.\n   *\n   * @param {number} hash - the hash code for <code>key</code>\n   * @param {*} key - the mapping key\n   * @param {*} value - the mapping value\n   * @param {?Entry} next - the next {@link Entry} (may be <code>null</code>)\n   * @return {Entry} The newly created {@link Entry}.\n   * @private\n   * @memberof NevisMap#\n   */\n  _createEntry: function(hash, key, value, next) {\n    return new Entry(hash, key, value, next, this._options)\n  }\n\n}, {\n\n  /**\n   * TODO: Document\n   *\n   * @param {number} hash -\n   * @param {*} key -\n   * @param {*} value -\n   * @param {?Entry} next -\n   * @param {NevisMap~Options} options -\n   * @public\n   * @static\n   * @constructor\n   * @extends Nevis\n   * @memberof NevisMap\n   */\n  Entry: Entry\n\n})\n\n/* istanbul ignore else */\nif (typeof Symbol === 'function') {\n  NevisMap.prototype[Symbol.iterator] = function() {\n    // TODO: Optimize, if needed\n    var entries = this.entries()\n    var iterator = entries[Symbol.iterator]\n\n    return {\n      next: function() {\n        return iterator.next()\n      }\n    }\n  }\n}\n\nmodule.exports = NevisMap\n\n/**\n * TODO: Document\n *\n * @callback NevisMap~ForEachCallback\n * @param {*} value -\n * @param {*} key -\n * @param {NevisMap} map -\n */\n\n/**\n * TODO: Document\n *\n * @typedef Object NevisMap~Options\n * @property {Nevis~EqualsOptions} [equals] -\n * @property {Nevis~HashCodeOptions} [hashCode] -\n */\n"],"names":["Entry","Nevis","extend","hash","key","value","next","options","this","_options","equals","obj","EqualsBuilder","append","build","hashCode","toString","NevisMap","entries","clear","delete","entrySet","forEach","callback","context","entry","call","get","has","hasKey","hasValue","keys","remove","set","setAll","size","toMap","Map","values","_createEntry","Symbol","prototype","iterator"],"mappings":";iQAwCIA,GAAQC,EAAMC,OAAO,QAAS,SAASC,EAAMC,EAAKC,EAAOC,EAAMC,GAQjEC,KAAKL,KAAOA,EASZK,KAAKJ,IAAMA,EASXI,KAAKH,MAAQA,EASbG,KAAKF,KAAOA,EASZE,KAAKC,SAAWF,IAQhBG,OAAQ,SAASC,GACf,GAAW,MAAPA,KAAiBA,YAAeX,IAClC,OAAO,CAGT,IAAIO,GAAUC,KAAKC,SAASC,MAE5B,QAAO,GAAIT,GAAMW,eACdC,OAAOL,KAAKJ,IAAKO,EAAIP,IAAKG,GAC1BM,OAAOL,KAAKH,MAAOM,EAAIN,MAAOE,GAC9BO,SAQLC,SAAU,WACR,GAAIR,GAAUC,KAAKC,SAASM,QAE5B,OAAOd,GAAMc,SAASP,KAAKJ,IAAKG,GAAWN,EAAMc,SAASP,KAAKH,MAAOE,IAQxES,SAAU,WACR,MAAOR,MAAKJ,IAAM,IAAMI,KAAKH,WAKhBL,EC1FbiB,EAAWhB,EAAMC,OAAO,WAAY,SAASgB,EAASX,GAUxDC,KAAKC,SAAWF,QAUhBY,MAAO,aAgBPC,OAAQ,SAAShB,GAEf,OAAO,GAaTc,QAAS,WAEP,UAUFG,SAAU,WAER,UAcFC,QAAS,SAASC,EAAUC,GAE1BhB,KAAKU,UAAUI,QAAQ,SAASG,GAC9BF,EAASG,KAAKF,EAASC,EAAM,GAAIA,EAAM,GAAIjB,OAC1CA,OAgBLmB,IAAK,SAASvB,GAEZ,MAAO,OAaTwB,IAAK,SAASxB,GACZ,MAAOI,MAAKqB,OAAOzB,IAYrByB,OAAQ,SAASzB,GAEf,OAAO,GAYT0B,SAAU,SAASzB,GAEjB,OAAO,GAUT0B,KAAM,WAEJ,UAkBFC,OAAQ,SAAS5B,GAEf,MAAO,OAcT6B,IAAK,SAAS7B,EAAKC,GAEjB,MAAOG,OAiBT0B,OAAQ,SAAShB,GAEf,MAAOV,OAUT2B,KAAM,WAEJ,MAAO,IAUTC,MAAO,WAEL,MAAO,IAAIC,KAAI7B,KAAKU,YAUtBoB,OAAQ,WAEN,UAQF5B,OAAQ,SAASC,GAEf,OAAO,GAQTI,SAAU,WAER,MAAO,IAQTC,SAAU,WAER,MAAO,IAcTuB,aAAc,SAASpC,EAAMC,EAAKC,EAAOC,GACvC,MAAO,IAAIN,GAAMG,EAAMC,EAAKC,EAAOC,EAAME,KAAKC,aAmBhDT,MAAOA,UAKa,kBAAXwC,UACTvB,EAASwB,UAAUD,OAAOE,UAAY,WAEpC,GAAIxB,GAAUV,KAAKU,UACfwB,EAAWxB,EAAQsB,OAAOE,SAE9B,QACEpC,KAAM,WACJ,MAAOoC,GAASpC,WAMPW"}